# 数据库

> 数据库相关内容

## 数据库优化

### 为什么要优化?

- 系统的吞吐量瓶颈往往出现在数据库的访问速度上;
- 随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢;
- 数据是存放在磁盘上的，读写速度无法和内存相比;

### 数据库结构优化

- **增加中间表**:对于需要经常联合查询的表，可以建立中间表以提高查询效率;
- **增加冗余字段**:设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度;
- **分库分表**:

    > 分库分表也带来了问题:分布式事务,跨库的join操作,范围查询,数据迁移,分布式ID等问题

    1. **水平分割**:按照分表算法将数据分散到不同的表中,即大量数据分散至多张表中;
    2. **垂直分割**:将数据按照常用字段和非常用字段进行分割,常用字段单独存放在一张表中;

### 数据库查询优化

- 查询时应明确指明查询范围及返回字段;
- 配置读写分离(主从复制),实现主写从读的方案;
- 为数据库添加缓存如ES/Redis等;
- 为查询字段添加索引,优化查询语句;

## 数据库事务4大特性

- **原子性**:事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- **一致性**:执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的;
- **持久性**:一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
- **隔离性**:并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的;

### 并发事务带来的问题

- **更新丢失**:多个事务更新同一条数据导致先提交的事务被覆盖
- **脏读**:其他事务读取到当前还未提交的数据
- **不可重复读**:在事务中前后两次查询同一条数据,由于其他事务的提交导致数据前后不一致的情况
- **幻读**:在事务中两次查询多条数据,由于其他事务的提交导致查询的数量不一致

### 数据库隔离级别
- Read Uncommitted(读取未提交内容)
- Read Committed(读取提交内容)
- Repeatable Read(可重读)
- Sserializable(可串行化)

各个隔离级别对并发事务问题的影响

| 隔离级别                         | 脏读 | 不可重复读 | 幻读 |
| -------------------------------- | ---- | ---------- | ---- |
| Read Uncommitted(读取未提交内容) | A    | A          | A    |
| Read Committed(读取提交内容)     | X    | A          | A    |
| Repeatable Read(可重读)          | X    | X          | A    |
| Sserializable(可串行化)          | X    | X          | X    |

## 数据库三范式

表结构在设计时应尽量满足三范式要求,必要时也可以不满足三范式,如订单表中的金额可根据单价*数量计算,若冗余金额字段,时间换空间增加查询效率;

- **第一范式(确保每列保持原子性)**:要求属性具有原子性，不可再分解;
- **第二范式(确保表中的每列都和主键相关)**:非主键字段必须依赖或关联主键;
- **第三范式(确保每列都和主键列直接相关,而不是间接相关)**:字段没有冗余;