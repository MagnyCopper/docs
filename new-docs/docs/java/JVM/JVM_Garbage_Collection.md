# JVM 垃圾回收 <!-- omit in toc -->

> JVM 能够自动对没有使用到的对象进行释放操作;

目录:

- [基础属性](#基础属性)
- [知识点](#知识点)
  - [对象存活识别算法](#对象存活识别算法)
  - [什么东西可以作为 GC Root?](#什么东西可以作为-gc-root)
  - [Java 种引用的种类](#java-种引用的种类)
  - [如何判断死亡对象是否回收?](#如何判断死亡对象是否回收)
  - [方法区的对象如何回收?](#方法区的对象如何回收)
  - [垃圾回收算法说明](#垃圾回收算法说明)
  - [垃圾回收器说明](#垃圾回收器说明)

## 基础属性

JVM 的垃圾回收主要经过以下几个步骤

- 判断对象是否存活;
- 判断对象是否需要回收;
- 垃圾回收算法

堆的垃圾回收:

- 对象

方法区的垃圾回收:

- 常量
- class 类对象

常见的垃圾回收算法:

- 标记-清除算法
- 标记-复制算法
- 标记-整理算法
- 分代收集算法

常见的垃圾回收器:

- Serial 收集器
- ParNew 收集器
- Parallel Scavenge 收集器
- Serial Old 收集器
- Parallel Old 收集器
- CMS 收集器
- G1 收集器
- ZGC 收集器

## 知识点

### 对象存活识别算法

JVM 中有以下 2 种对象存活识别算法

- 引用计数
- 可达性分析

横向比较一下

| 方法       | 说明                                                                                     | 优点                                           | 缺点                                     |
| :--------- | :--------------------------------------------------------------------------------------- | :--------------------------------------------- | :--------------------------------------- |
| 引用计数   | 在对象头部维护一个引用计数,有外部引用则加 1,外部引用移除则减 1,到 0 时可以进行回收       | 实现简单效率较高                               | 无法处理循环引用的场景,即 A->B 同时 B->A |
| 可达性分析 | 所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象 | 有效解决了引用计数法循环引用对象无法回收的问题 | -                                        |

### 什么东西可以作为 GC Root?

GC Root 主要是指以下对象:

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

### Java 种引用的种类

Java 种存在以下 4 中引用类型:

| 引用类型                    | 说明                                        | 垃圾回收       |
| :-------------------------- | :------------------------------------------ | :------------- |
| 强引用（Strong Reference）  | 类似 `Object obj = new Object()` 这类的引用 | 不会回收       |
| 软引用（Soft Reference）    | 引用强度稍弱                                | 内存不足时回收 |
| 弱引用（Weak Reference）    | 引用强度更弱                                | 一定回收       |
| 虚引用（Phantom Reference） | 引用强度最弱                                | 垃圾回收       |

### 如何判断死亡对象是否回收?

1. 被判断为死亡对象;
2. 判断是需要执行`finalize()`方法(若该对象已经执行过`finalize()`/未复写`finalize()`方法,则可以清除该对象)
3. 若需要执行则将对象加入 F-Queue 对象等待`finalize()`执行完毕(随机的也有可能不执行);
4. 可以清除该对象

### 方法区的对象如何回收?

方法区种主要存在 2 类对象

| 对象类型 | 回收说明                                                                                                           |
| :------- | :----------------------------------------------------------------------------------------------------------------- |
| 常量     | 常量池中的常量是否存在外部引用若无则回收                                                                           |
| 类对象   | 满足:1.堆中该类的对象全部回收;2.加载该类的 ClassLoader 已被回收;3.对应的 Class 对象无任何引用;的对象**可以**被回收 |

### 垃圾回收算法说明

| 算法          | 说明                                                                                | 优点             | 缺点                    |
| :------------ | :---------------------------------------------------------------------------------- | :--------------- | :---------------------- |
| 标记-清除算法 | 1.垃圾识别算法标记垃圾;2.垃圾对象回收                                               | 实现简单         | 1.效率低;2.产生内存碎片 |
| 标记-复制算法 | 1.将内存分为 2 块空间;2.在空间 1 识别垃圾对象;2.将存活对象复制到空间 2;3.清空空间 1 | 不会产生内存碎片 | 1.内存利用率低          |
| 标记-整理算法 | 1.垃圾识别算法标记垃圾;2.垃圾对象回收 3.将存活对象按照内存顺序排布;                 | -                | -                       |
| 分代收集算法  | 针对不同的堆区域特点选择不同的垃圾回收算法                                          | -                | -                       |

### 垃圾回收器说明

| 回收器                   | 特点               | 新生代    | 老年代    |
| :----------------------- | :----------------- | :-------- | :-------- |
| Serial 收集器            | 单线程             | 标记-复制 | 标记-整理 |
| ParNew 收集器            | 多线程             | 标记-复制 | 标记-整理 |
| Parallel Scavenge 收集器 | 多线程,高吞吐量    | 标记-复制 | 标记-整理 |
| Serial Old 收集器        | 单线程             | -         | 标记-整理 |
| Parallel Old 收集器      | 多线程             | -         | 标记-整理 |
| CMS 收集器               | 多线程,并发,低停顿 | -         | 标记-清除 |
| G1 收集器                | 多线程,并发        | -         | 标记-复制 |
| ZGC 收集器               | 多线程,并发        | -         | 标记-复制 |
