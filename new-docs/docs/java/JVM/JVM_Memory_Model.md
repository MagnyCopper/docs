# JVM 内存模型 <!-- omit in toc -->

> Java 虚拟机的内存结构及各个部分的解释说明
> 目录:

- [基础属性](#基础属性)
  - [程序计数器](#程序计数器)
  - [Java 虚拟机栈](#java-虚拟机栈)
  - [本地方法栈](#本地方法栈)
  - [堆](#堆)
  - [方法区](#方法区)
- [知识点](#知识点)
  - [逃逸分析](#逃逸分析)
  - [空间分配担保机制](#空间分配担保机制)
  - [对象晋升至老年代的年龄](#对象晋升至老年代的年龄)
  - [对象分配过程](#对象分配过程)
  - [Full GC / Major GC 触发条件](#full-gc--major-gc-触发条件)

## 基础属性

JVM 的内存模型主要包含以下几个部分:

- 程序计数器(PC)
- Java 虚拟机栈
- 本地方法栈
- 堆
- 方法区(元数据区)

### 程序计数器

程序技术器是一块较小的内存空间,主要用来保存当前线程正在执行的那条字节码的地址(若是 native 方法则为 Undefined)

**主要特点:**

- 一块较小的内存空间
- 线程私有
- 随线程创建而创建,随着线程结束而销毁
- 通过改变程序计数器来实现代码流程的控制;
- 多线程场景方便在线程间切换时定位上次程序执行的位置;

### Java 虚拟机栈

用来描述 Java 方法运行过程的内存模型,基本单位是**栈帧**

栈帧中主要保存以下内容:

- 局部变量表(原始数据类型,对象引用,返回地址)
- 操作数栈
- 动态链接
- 方法出口信息

**主要特点:**

- 线程私有
- 栈顶的栈帧就是当前正在执行的方法;
- 当调用其他方法时将生成新的栈帧并入栈;
- 方法执行过程中创建局部变量时都将写入局部变量表,大小在编译时即可确定;
- 方法结束时栈顶帧出栈,若有返回值则写入新栈顶帧的操作数栈.无返回值则不写入;
- 随线程创建而创建,随着线程结束而销毁

### 本地方法栈

与 Java 虚拟机栈大体类似,只不过是用来处理 native 方法的;

若 JVM 本身并不提供 native 方法支持,可以不实现本地方法栈;

**主要特点:**

- 线程私有

### 堆

用来保存对象的内存空间,几乎全部对象都存储在堆中(存在部分栈上分配的场景);

主要分为以下几个部分:

- 新生代(Eden)
  - TLAB(Thread Local Allocation Buffer 线程本地分配缓存区/线程私有)
  - From Survior(S0)
  - To Survivor(S1)
- 老年代
- 字符串常量池(Hotspot 实现)

**主要特点:**

- 虚拟机启动时创建;
- 垃圾回收的主要场所;
- 关于 From Survior 和 To Survivor:复制之后交换,谁空谁是 to;
- 不同区域采用不同的算法进行垃圾回收(分代回收效率更高);
- 默认新生代:老年代=1:2
- 默认 Eden:S0:S1=8:1:1
- 大部分对象都是在 Eden 创建的,Eden 放不下的直接进入老年代(如大数组);
- 对象在新生代坚持 15 次垃圾回收后依然幸存将移动至老年代;
- 频繁在新生代回收,偶尔在老年代回收,几乎不会在方法区回收;
- 只有 Eden 空间满了才会触发 Minor GC 并顺便回收 S0 和 S1;

### 方法区

方法区是堆的一个逻辑部分,也称元空间/永久代,位于**直接内存**中,主要保存以下内容:

- 类信息
- 常量(常量池)
- 静态变量
- 即时编译器编译后的代码

## 知识点

### 逃逸分析

虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术,使用逃逸分析可以大大降低代码的执行时间和内存消耗;

**逃逸的例子:**

1. 函数局部变量的 return 返回;

**JVM 的逃逸分析会带来 3 个优势:**

- 标量替换:虚拟机确认对象不会逃逸且可以被进一步分解时,会使用在栈上创建对象的成员变量的方式创建局部变量;
- 同步擦除:虚拟机确定当前对象只有当前线程使用，那么就会移除该对象的同步锁(synchronized)
- 栈上分配对象:虚拟机确认不会发生逃逸的对象将在栈上创建,跟随栈一起销毁,免除 GC 回收流程;

在当前 Hotspot 实现中,JVM 是通过**标量替换**的方式实现**栈上分配对象**的

### 空间分配担保机制

在发生 Minor GC 之前，虚拟机会检查**老年代最大可用的连续空间是否大于新生代所有对象的总空间**;

若若大于则为此次 Minor GC 为安全 GC;

若允许不安全的 GC 则检查**老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**;

若大于则进行一次 Minor GC,若小于则进行一次 Full GC;

### 对象晋升至老年代的年龄

默认情况下当对象年龄达到**15**时晋升至老年代，可以通过`-XX:MaxTenuringThreshold`进行修改；

晋升年龄也会动态更新,计算方式如下:

> Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值

### 对象分配过程

1. 首先在 Eden 创建对象,大小超过限制的直接在老年代创建;
2. Eden 空间满了触发 Minor GC
3. Eden 的存活对象移至 Survivor0 区;
4. 再次触发 Minor GC 时,将 Eden 及 S0 存活对象移至 S1;
5. 如此往复直到对象年龄达到 15,将其移动至老年代;

### Full GC / Major GC 触发条件

**Full GC:**

- 显示调用`System.gc()`;
- 老年代空间不足;

**Major GC:**

- 触发 Full GC 时;
- Eden 空间不足;
