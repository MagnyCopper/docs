# JVM内存模型 <!-- omit in toc -->

> Java虚拟机的内存结构及各个部分的解释说明
目录:

- [基础属性](#基础属性)
  - [程序计数器](#程序计数器)
  - [Java虚拟机栈](#java虚拟机栈)
  - [本地方法栈](#本地方法栈)
  - [堆](#堆)
  - [方法区](#方法区)
- [知识点](#知识点)
  - [对象分配过程:](#对象分配过程)
  - [Full GC /Major GC 触发条件:](#full-gc-major-gc-触发条件)

## 基础属性

JVM的内存模型主要包含以下几个部分:

- 程序计数器(PC)
- Java虚拟机栈
- 本地方法栈
- 堆
- 方法区(元数据区)

### 程序计数器

程序技术器是一块较小的内存空间,主要用来保存当前线程正在执行的那条字节码的地址(若是native方法则为Undefined)

主要特点:

- 一块较小的内存空间
- 线程私有
- 随线程创建而创建,随着线程结束而销毁
- 通过改变程序计数器来实现代码流程的控制;
- 多线程场景方便在线程间切换时定位上次程序执行的位置;

### Java虚拟机栈

用来描述Java方法运行过程的内存模型,基本单位是**栈帧**

栈帧中主要保存以下内容:

- 局部变量表(原始数据类型,对象引用,返回地址)
- 操作数栈
- 动态链接
- 方法出口信息

主要特点:

- 线程私有
- 栈顶的栈帧就是当前正在执行的方法;
- 当调用其他方法时将生成新的栈帧并入栈;
- 方法执行过程中创建局部变量时都将写入局部变量表,大小在编译时即可确定;
- 方法结束时栈顶帧出栈,若有返回值则写入新栈顶帧的操作数栈.无返回值则不写入;
- 随线程创建而创建,随着线程结束而销毁

### 本地方法栈

与Java虚拟机栈大体类似,只不过是用来处理native方法的;

若JVM本身并不提供native方法支持,可以不实现本地方法栈;

主要特点:

- 线程私有

### 堆

用来保存对象的内存空间,几乎全部对象都存储在堆中;

主要分为以下几个部分:

- 新生代(Eden)
  - TLAB(Thread Local Allocation Buffer线程本地分配缓存区/线程私有)
  - From Survior(S0)
  - To Survivor(S1)
- 老年代

主要特点:

- 虚拟机启动时创建;
- 垃圾回收的主要场所;
- 关于From Survior和To Survivor:复制之后交换,谁空谁是to;
- 不同区域采用不同的算法进行垃圾回收(分代回收效率更高);
- 新生代:老年代=1:2
- Eden:S0:S1=8:1:1
- 大部分对象都是在Eden创建的,Eden放不下的直接进入老年代(如大数组);
- 对象在新生代坚持15次垃圾回收后依然幸存将移动至老年代;
- 频繁在新生代回收,偶尔在老年代回收,几乎不会在方法区回收;
- 只有Eden空间满了才会触发Minor GC并顺便回收S0和S1;

### 方法区

方法区是堆的一个逻辑部分,也称元空间/永久代,位于直接内存中,主要保存以下内容:

- 类信息
- 常量(常量池)
- 静态变量
- 即时编译器编译后的代码

## 知识点

### 对象分配过程:

1. 首先在Eden创建对象,大小超过限制的直接在老年代创建;
2. Eden空间满了触发Minor GC
3. Eden的存活对象移至Survivor0区;
4. 再次触发Minor GC时,将Eden及S0存活对象移至S1;
5. 如此往复直到对象年龄达到15,将其移动至老年代;

### Full GC /Major GC 触发条件:

Full GC:

- 显示调用`System.gc()`;
- 老年代空间不足;

Major GC:

- 触发Full GC时;
- Eden空间不足;
