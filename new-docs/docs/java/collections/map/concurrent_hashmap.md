# ConcurrentHashMap <!-- omit in toc -->

> 这是一个线程安全的 HashMap

目录:

- [基础属性](#基础属性)
- [知识点](#知识点)
  - [如何保证线程安全](#如何保证线程安全)
  - [并发度含义](#并发度含义)
  - [如何在链表和红黑树间切换](#如何在链表和红黑树间切换)
  - [如何扩容](#如何扩容)
  - [put 元素的流程](#put-元素的流程)

## 基础属性

- 线程安全;
- key 和 value 均不能为 null;
- 无序保存键值对;
- 默认数组长度 16
- 默认负载因子:0.75
- 默认并发度:16
- 数据结构:数组+链表[单向链表]/红黑树[双向链表]
- 锁:CAS+synchronized[对链表头节点/红黑树根节点加锁/限制初始化的线程数]
- 用 volatile 修饰了 value 和 next 指针保证读取时的可见性;

## 知识点

### 如何保证线程安全

添加元素时采用 CAS+synchronized 的方式保证线程安全，同时使用 volatile 修饰 value 和 next 指针保证了 get 时的可见性；

### 并发度含义

能够同时更新 ConcurrentHashMap 且不产生锁竞争的最大线程数;

默认值为 16，若通过构造方法指定，则 ConcurrentHashMap 会使用大于等于该值的最小的 2 的幂指数;

### 如何在链表和红黑树间切换

当满足以下条件时链表->红黑树:

- 链表长度>8;
- 数组长度大于 64;

当满足以下条件时红黑树->链表:

- 扩容时[resize],拆分的 high/low 两颗红黑树的节点数<6;
- 移除 key 时[remove],若红黑树满足退化条件[root 为空/root.right 为空/root.left 为空/root.left.left 为空]

### 如何扩容

当满足以下条件时触发扩容机制

- 添加元素时
- 当前 Map 的 size()>数组长度\*负载因子

每次扩容时:

- 将数组长度翻倍[X2]

### put 元素的流程

1. 计算 hash 值及数组下标；
2. 若第一次 put 则进行数组的初始化；
3. 根据下标查找对应位置，若为 null 即没有链表结构则使用 CAS 创建头结点；
4. 若对应位置是转移节点[即发生扩容时]等待扩容结束；
5. 若对应位置是正常链表节点则 synchronized 加锁节点按照链表/红黑树的方式插入；
6. 完成插入后判断是否需要进行扩容[扩容时数组复制成功将节点修改为转移节点]；
7. 使用 CAS 更新 size;
